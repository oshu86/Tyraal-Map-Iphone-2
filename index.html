<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>index – Interaktiv karta (mobiloptimerad v2)</title>
<style>
  :root { --bg:#0f1115; --ink:#e6e6e6; --muted:#2a3142; --panel:#141822; --shadow: rgba(0,0,0,.45); --accent:#ffd166; --line:#7dd3fc; --vh: 1vh; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow: hidden; }

  /* Stage / world */
  #stage { position: relative; width: 100vw; height: calc(var(--vh) * 100); overflow: hidden; touch-action: none; }
  #world { position: absolute; left: 0; top: 0; transform-origin: 0 0; will-change: transform; }
  #map { display:block; user-select: none; -webkit-user-drag: none; pointer-events: none; max-width: none; }

  /* Markörer */
  .marker { position: absolute; width: 32px; height: 32px; transform: translate(-50%, -100%); cursor: pointer;
            background-image: url('ikonkarta.png'); background-size: contain; background-position:center; background-repeat:no-repeat; }
  .marker.open { background-image: url('ikonkarta2.png'); filter: drop-shadow(0 0 6px var(--accent)); }

  /* Desktop-sidopanel */
  #sidebar { position: fixed; left: 0; top: 0; height: 100dvh; width: 360px; max-width: 90vw; background: rgba(20,24,34,.96);
             border-right: 1px solid var(--muted); box-shadow: 0 6px 20px var(--shadow); z-index: 30; display: none; }
  #sidebar header { display:flex; align-items:center; justify-content: space-between; gap:8px; padding:10px 12px; border-bottom:1px solid #262c3b; }
  #sidebar h3 { margin:0; font-size:16px; font-weight:600; opacity:.9; }
  .mini { border:1px solid var(--muted); background:#1a2030; color:#ddd; padding:6px 10px; border-radius:8px; cursor:pointer; }
  #content { height: calc(100dvh - 52px); overflow:auto; padding:12px; }
  #noteBody { background:#0e1220; border:1px solid #2a3142; border-radius:8px; padding:10px; min-height: 180px; white-space: pre-wrap; outline:none; }
  #noteBody:focus { box-shadow: inset 0 0 0 2px #3b82f6; }
  .note-img { max-width: 100%; height: auto; display:block; margin:8px 0; border-radius:6px; border:1px solid #2a3142; cursor: zoom-in; }

  #stage.grabbing, body.grabbing { cursor: grabbing; }

  /* Lightbox */
  #lightbox { position: fixed; inset: 0; background: rgba(0,0,0,.9); display: none; align-items: center; justify-content: center; z-index: 100; }
  #lightbox img { max-width: 96vw; max-height: 96vh; box-shadow: 0 10px 35px rgba(0,0,0,.6); border-radius: 8px; }

  /* Overlay SVG för mätning */
  #overlay { position:absolute; left:0; top:0; overflow:visible; pointer-events:none; }
  .measure-line { stroke: var(--line); stroke-width: 2; fill: none; vector-effect: non-scaling-stroke; }

  /* Toolbox (sticky) */
  #toolbox { position: fixed; left: 8px; right: 8px; top: env(safe-area-inset-top, 8px); display: flex; gap: 8px; z-index: 60; align-items:center; flex-wrap: wrap; }
  .toolbtn { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:8px 10px; border-radius:10px; cursor:pointer; font-size:14px; }
  .toolbtn.active { outline: 2px solid #60a5fa; }
  .pill { background:#0b1220; border:1px solid #2a3142; padding:6px 10px; border-radius:999px; font-size:14px; }

  /* Skallinje (UI-overlay) */
  #scalebar { position: fixed; left: 14px; bottom: calc(14px + env(safe-area-inset-bottom)); z-index: 70; color:#e5e7eb; font-size: 12px; }
  #scalebar .bar { height: 6px; background: #e5e7eb; border-radius: 3px; box-shadow: 0 1px 0 rgba(0,0,0,.35) inset; }
  #scalebar .label { margin-top: 6px; text-align: center; opacity: .9; }

  /* Player-banner (avaktiverad i v2) */
  #playerBanner { display:none; }

  /* Mobiljusteringar */
  @media (max-width: 820px) {
    .toolbtn { padding:6px 8px; font-size:12px; }
    .pill { padding:4px 8px; font-size:12px; }
    #sidebar { display:none !important; }
  }

  /* Bottenskiva (mobil-notiser) */
  #sheet { position: fixed; left: 0; right: 0; bottom: 0; z-index: 90; display:none; }
  #sheetPanel { margin: 0 auto; max-width: 880px; background: rgba(20,24,34,.98); border-top-left-radius: 16px; border-top-right-radius: 16px; border:1px solid #2a3142; box-shadow: 0 -8px 24px rgba(0,0,0,.45); padding: 10px 12px 14px; transform: translateY(0); will-change: transform; }
  #sheetHeader { display:flex; align-items:center; justify-content: space-between; gap:8px; padding-bottom:8px; border-bottom:1px solid #262c3b; }
  #sheetHandle { width: 44px; height: 5px; background:#3b4154; border-radius: 999px; margin: 4px auto 10px; opacity:.85; touch-action:none; }
  #sheetBody { max-height: 48dvh; overflow:auto; }
  .mini-ghost { background:transparent; border:1px solid #374151; color:#e5e7eb; padding:6px 10px; border-radius:10px; cursor:pointer; }
</style>
</head>
<body>
  <aside id="sidebar">
    <header>
      <h3 id="sidebarTitle">Markering</h3>
      <div id="editorBtns">
        <button id="addImg" class="mini" type="button" title="Lägg till bild">+ Bild</button>
        <input id="imgInput" type="file" accept="image/*" style="display:none" />
      </div>
    </header>
    <div id="content">
      <div id="noteBody" contenteditable="true" spellcheck="false">Skriv din not här...</div>
      <p id="pasteHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: Klistra in (Ctrl/Cmd+V) eller dra‑och‑släpp en bild direkt i textfältet. Klicka på en bild för stor visning.</p>
    </div>
  </aside>

  <!-- Mobil-bottenskiva -->
  <div id="sheet">
    <div id="sheetPanel">
      <div id="sheetHandle"></div>
      <div id="sheetHeader">
        <h3 id="sheetTitle" style="margin:0;font-size:15px">Markering</h3>
        <div id="sheetBtns">
          <button id="mAddImg" class="mini-ghost" type="button" title="Lägg till bild">+ Bild</button>
          <button id="sheetClose" class="mini-ghost" type="button" title="Stäng">Stäng</button>
          <input id="mImgInput" type="file" accept="image/*" style="display:none" />
        </div>
      </div>
      <div id="sheetBody" contenteditable="true" spellcheck="false"></div>
      <p id="sheetHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: tryck för att skriva, bilder kan läggas till via + Bild.</p>
    </div>
  </div>

  <div id="toolbox">
    <span class="pill" id="modeLabel">Läge: Notiser</span>
    <button id="btnModeNotes" class="toolbtn active" title="Skapa/hantera notiser">Notiser</button>
    <button id="btnModeMeasure" class="toolbtn" title="Mät avstånd">Mät</button>
    <button id="btnUndo" class="toolbtn" title="Ångra senaste mätpunkt">Ångra</button>
    <button id="btnReset" class="toolbtn" title="Ny mätning">Ny mätning</button>
    <button id="btnExport" class="toolbtn" title="Exportera data.json (inbäddade bilder)">Export</button>
    <span id="readout" class="pill">Skala: okänd</span>
  </div>

  <div id="playerBanner">Player‑läge (read‑only) – läser data.json</div>

  <div id="scalebar">
    <div class="bar" id="sbBar" style="width:120px"></div>
    <div class="label" id="sbLabel">—</div>
  </div>

  <div id="stage">
    <div id="world">
      <img id="map" src="Tyraal.webp" alt="Tyraal-karta" />
      <svg id="overlay"></svg>
    </div>
  </div>

  <div id="lightbox"><img id="lightboxImg" alt="" /></div>

<script>
(function(){
  // ===== Stabil 100vh på mobiler =====
  const setVH = () => document.documentElement.style.setProperty('--vh', (visualViewport ? visualViewport.height : window.innerHeight) * 0.01 + 'px');
  setVH(); if (window.visualViewport){ visualViewport.addEventListener('resize', setVH); } else { window.addEventListener('resize', setVH); }

  const IS_PLAYER = (location.hash === '#player') || (new URLSearchParams(location.search).get('mode') === 'player');
  const IS_MOBILE = matchMedia('(max-width: 820px)').matches;

  // ===== SKALA =====
  // 250 000 m = 1073.6 px
  const METERS_PER_PIXEL = 250000 / 1073.6; // ≈ 232.77 m/px
  const MAP_WIDTH = 8192, MAP_HEIGHT = 5462; // fallback
  let metersPerPixelOverride = NaN; 
  const getMetersPerPixel = () => (isNaN(metersPerPixelOverride) ? METERS_PER_PIXEL : metersPerPixelOverride);

  // ===== DOM =====
  const stage = document.getElementById('stage');
  const world = document.getElementById('world');
  const map = document.getElementById('map');
  const overlay = document.getElementById('overlay');
  const sidebar = document.getElementById('sidebar');
  const sidebarTitle = document.getElementById('sidebarTitle');
  const editorBtns = document.getElementById('editorBtns');
  const noteBody = document.getElementById('noteBody');
  const pasteHint = document.getElementById('pasteHint');
  const addImgBtn = document.getElementById('addImg');
  const imgInput = document.getElementById('imgInput');
  const mAddImgBtn = document.getElementById('mAddImg');
  const mImgInput = document.getElementById('mImgInput');
  const sheet = document.getElementById('sheet');
  const sheetBody = document.getElementById('sheetBody');
  const sheetTitle = document.getElementById('sheetTitle');
  const sheetClose = document.getElementById('sheetClose');
  const sheetHint = document.getElementById('sheetHint');
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');
  const modeLabel = document.getElementById('modeLabel');
  const btnModeNotes = document.getElementById('btnModeNotes');
  const btnModeMeasure = document.getElementById('btnModeMeasure');
  const btnUndo = document.getElementById('btnUndo');
  const btnReset = document.getElementById('btnReset');
  const btnExport = document.getElementById('btnExport');
  const readout = document.getElementById('readout');
  const sbBar = document.getElementById('sbBar');
  const sbLabel = document.getElementById('sbLabel');

  // ===== Kamera (pinch-zoom fixad) =====
  let scale = 1, MIN = 1, MAX = 24, startScale = 1; // MIN sätts till nära fit senare
  let tx = 0, ty = 0, imgW = 0, imgH = 0;

  function getPanBounds(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w = imgW * scale, h = imgH * scale;
    // Om bilden är mindre än viewport: centrera och lås position
    const centerX = (vw - w) / 2, centerY = (vh - h) / 2;
    if (w <= vw && h <= vh) return { minTx:centerX, maxTx:centerX, minTy:centerY, maxTy:centerY };
    if (w <= vw) return { minTx:centerX, maxTx:centerX, minTy: Math.min(0, vh - h), maxTy: 0 };
    if (h <= vh) return { minTx: Math.min(0, vw - w), maxTx: 0, minTy:centerY, maxTy:centerY };
    return { minTx: Math.min(0, vw - w), maxTx: 0, minTy: Math.min(0, vh - h), maxTy: 0 };
  }
  function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }
  function clampPan(){ const b = getPanBounds(); tx = clamp(tx, b.minTx, b.maxTx); ty = clamp(ty, b.minTy, b.maxTy); }

  function applyTransform(){
    world.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    world.querySelectorAll('.marker').forEach(el => { el.style.transform = `translate(-50%, -100%) scale(${1/scale})`; });
    overlay.setAttribute('width', imgW); overlay.setAttribute('height', imgH);
    updateScaleBar();
  }

  function zoomAt(screenX, screenY, factor){
    const rect = stage.getBoundingClientRect();
    const x = screenX - rect.left; const y = screenY - rect.top;
    const wx = (x - tx) / scale; const wy = (y - ty) / scale;
    const ns = clamp(scale * factor, MIN, MAX);
    tx = x - wx * ns; ty = y - wy * ns; scale = ns; clampPan(); applyTransform();
  }

  function fitToScreenAndCenter(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w0 = map.naturalWidth || MAP_WIDTH; const h0 = map.naturalHeight || MAP_HEIGHT;
    imgW = w0; imgH = h0;
    const s = Math.min(vw / imgW, vh / imgH);
    startScale = s; scale = s; // start i fit
    MIN = startScale * 0.98;   // tillåt bara marginellt mindre än fit för att undvika svart runtom
    const w = imgW * scale, h = imgH * scale;
    tx = (vw - w)/2; ty = (vh - h)/2; applyTransform();
  }

  // Mushjul
  stage.addEventListener('wheel', e => { e.preventDefault(); const f = e.deltaY < 0 ? 1.15 : 1/1.15; zoomAt(e.clientX, e.clientY, f); }, {passive:false});

  // Pekhändelser med bättre stabilitet
  const pointers = new Map();
  let lastDist = null;
  stage.addEventListener('pointerdown', e => { stage.setPointerCapture(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); });
  stage.addEventListener('pointermove', e => {
    if (!pointers.has(e.pointerId)) return; pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const pts = [...pointers.values()];
    if (pts.length === 1){ // pan
      const p = pts[0]; const d = pointers.get('_start') || {x:p.x,y:p.y,tx,ty};
      if (!pointers.has('_start')) pointers.set('_start', d);
      tx = d.tx + (p.x - d.x); ty = d.ty + (p.y - d.y); clampPan(); applyTransform();
    } else if (pts.length === 2){ // pinch
      pointers.delete('_start');
      const [a,b] = pts; const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2; const dist = Math.hypot(b.x-a.x, b.y-a.y);
      if (lastDist==null) { lastDist = dist; return; }
      const factor = dist / lastDist; lastDist = dist; zoomAt(midX, midY, factor);
    }
  });
  function endPointer(e){ pointers.delete(e.pointerId); if (pointers.size<2) lastDist=null; if (!pointers.has('_start')) pointers.delete('_start'); }
  stage.addEventListener('pointerup', endPointer); stage.addEventListener('pointercancel', endPointer);

  // ===== Lagring (IndexedDB + localStorage) =====
  const LSK = 'tyraal_markers_meta_v13';
  const DB_NAME = 'tyraal_db'; const DB_STORE = 'notes';
  let db = null;
  function openDB(){ return new Promise((resolve, reject) => { const req = indexedDB.open(DB_NAME, 1); req.onupgradeneeded = () => { db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' }); }; req.onsuccess = () => { db = req.result; resolve(db); }; req.onerror = () => reject(req.error); }); }
  function idbGet(id){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readonly'); const st = tx.objectStore(DB_STORE); const r = st.get(id); r.onsuccess = () => resolve(r.result?.html || ''); r.onerror = () => reject(r.error); }); }
  function idbSet(id, html){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readwrite'); const st = tx.objectStore(DB_STORE); const r = st.put({ id, html }); r.onsuccess = () => resolve(); r.onerror = () => reject(r.error); }); }
  function idbBulkGet(ids){ return Promise.all(ids.map(id => idbGet(id).then(html => ({ id, html })))); }
  function saveMeta(){ if (IS_PLAYER) return; const out = [...world.querySelectorAll('.marker')].map(m => ({ id: m.dataset.id, x: parseFloat(m.style.left), y: parseFloat(m.style.top) })); try { localStorage.setItem(LSK, JSON.stringify(out)); } catch(e){} }
  async function saveHTML(id, html){ if (IS_PLAYER) return; try { await idbSet(id, html); } catch(e){} }
  async function loadAllFromLocal(){ const meta = JSON.parse(localStorage.getItem(LSK) || '[]'); meta.forEach(o => createMarker(o.x, o.y, o.id, false)); const htmls = await idbBulkGet(meta.map(m => m.id)); htmls.forEach(({id, html}) => { store[id] = { html: html || '' }; }); }

  // ===== Player: data.json =====
  async function loadAllFromJSON(){
    try {
      const res = await fetch('data.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Kunde inte läsa data.json');
      const data = await res.json();
      if (typeof data.metersPerPixel === 'number' && isFinite(data.metersPerPixel)) metersPerPixelOverride = data.metersPerPixel;
      if (Array.isArray(data.markers)){
        data.markers.forEach(m => { createMarker(m.x, m.y, m.id, false); store[m.id] = { html: m.html || '' }; });
      }
    } catch (err){ console.error(err); alert('Kunde inte ladda spelardata (data.json).'); }
  }

  // ===== Per‑markör cache =====
  const store = {}; let openId = null;

  // ===== Bildinmatning (inbäddade data-URLer) =====
  let inserting = false, handlersBound = false;
  function fileToDataURL(file){ return new Promise((resolve, reject) => { const r=new FileReader(); r.onload=()=>resolve(r.result); r.onerror=reject; r.readAsDataURL(file); }); }
  async function insertImagesFromFiles(targetEl, files){
    if (inserting) return; inserting = true;
    try {
      for (const f of files){ if (!f || !f.type || !f.type.startsWith('image/')) continue; const data = await fileToDataURL(f); const img = document.createElement('img'); img.className = 'note-img'; img.src = data; attachImageClick(img); targetEl.appendChild(img); }
      if (openId){ const html = (IS_MOBILE ? sheetBody.innerHTML : noteBody.innerHTML); store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }
    } finally { inserting = false; }
  }
  function attachImageClick(img){ img.addEventListener('click', e => { e.stopPropagation(); openLightbox(img.src); }); }

  function bindOnce(){ if (handlersBound) return; handlersBound = true; if (!IS_PLAYER){
      addImgBtn?.addEventListener('click', () => { imgInput.value=''; imgInput.click(); });
      imgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(noteBody, files); imgInput.value=''; });
      mAddImgBtn?.addEventListener('click', () => { mImgInput.value=''; mImgInput.click(); });
      mImgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(sheetBody, files); mImgInput.value=''; });
      const pasteHandler = async (e, target) => { const items = e.clipboardData?.items || []; const files = []; for (const it of items){ if (it.kind==='file' && it.type.startsWith('image/')) files.push(it.getAsFile()); } if (files.length){ e.preventDefault(); e.stopPropagation(); if (!inserting) await insertImagesFromFiles(target, files); } };
      noteBody?.addEventListener('paste', e => pasteHandler(e, noteBody));
      sheetBody?.addEventListener('paste', e => pasteHandler(e, sheetBody));
      const inputHandler = async (target) => { if(openId){ const html = target.innerHTML; store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }}
      noteBody?.addEventListener('input', () => inputHandler(noteBody));
      sheetBody?.addEventListener('input', () => inputHandler(sheetBody));
    }
  }

  // ===== Lightbox =====
  function openLightbox(src){ lightboxImg.src = src; lightbox.style.display = 'flex'; }
  function closeLightbox(){ lightbox.style.display = 'none'; lightboxImg.src = ''; }
  lightbox.addEventListener('click', closeLightbox);

  // ===== Markörer =====
  function uid(){ return Math.random().toString(36).slice(2,9); }
  function clientToWorldXY(x,y){ const rect = stage.getBoundingClientRect(); const cx = x - rect.left; const cy = y - rect.top; return { wx: (cx - tx) / scale, wy: (cy - ty) / scale }; }

  stage.addEventListener('dblclick', e => {
    if (mode !== 'notes' || IS_PLAYER) return;
    if (e.target.classList && (e.target.classList.contains('marker') || e.target.closest('#sidebar') || e.target.closest('#sheet'))) return;
    e.preventDefault();
    const { wx, wy } = clientToWorldXY(e.clientX, e.clientY);
    const id = uid(); store[id] = { html: 'Skriv din not här...' };
    createMarker(wx, wy, id, true); openMarker(id);
  }, { passive:false });

  function createMarker(wx, wy, id, saveNow=true){
    if (!isFinite(wx) || !isFinite(wy)) return null;
    const m = document.createElement('div'); m.className = 'marker'; m.dataset.id = id; m.style.left = wx + 'px'; m.style.top = wy + 'px';
    m.addEventListener('click', ev => { ev.stopPropagation(); if (openId === id) { closePanels(); } else { openMarker(id); } });
    m.addEventListener('contextmenu', async ev => { if (IS_PLAYER) return; ev.preventDefault(); if (confirm('Ta bort denna markering och dess notis?')) { if (openId === id) closePanels(); world.removeChild(m); delete store[id]; saveMeta(); try { await idbSet(id, ''); } catch(_){} } });
    // Dra markör (GM)
    let draggingLocal = false; let dx = 0, dy = 0;
    m.addEventListener('pointerdown', ev => { if (mode !== 'notes' || IS_PLAYER) return; if (ev.button!==0 && ev.pointerType==='mouse') return; draggingLocal = true; const p=clientToWorldXY(ev.clientX, ev.clientY); dx = p.wx - parseFloat(m.style.left); dy = p.wy - parseFloat(m.style.top); document.body.classList.add('grabbing'); stage.classList.add('grabbing'); ev.preventDefault(); m.setPointerCapture(ev.pointerId); });
    m.addEventListener('pointermove', ev => { if (!draggingLocal) return; const p=clientToWorldXY(ev.clientX, ev.clientY); m.style.left = (p.wx - dx) + 'px'; m.style.top = (p.wy - dy) + 'px'; });
    m.addEventListener('pointerup', () => { if (draggingLocal){ draggingLocal=false; document.body.classList.remove('grabbing'); stage.classList.remove('grabbing'); saveMeta(); } });

    world.appendChild(m);
    if (saveNow) saveMeta();
    return m;
  }

  function openMarker(id){
    if (openId && openId !== id){ const prev = world.querySelector(`.marker[data-id="${openId}"]`); if (prev) prev.classList.remove('open'); }
    openId = id; const marker = world.querySelector(`.marker[data-id="${id}"]`); if (marker) marker.classList.add('open');
    const render = (html) => {
      if (IS_MOBILE){
        sheetTitle.textContent = 'Markering ' + id; sheet.style.display = 'block';
        sheetBody.innerHTML = html; sheetBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        sheetHint.style.display = IS_PLAYER ? 'none' : 'block';
        openSheet('half');
      } else {
        sidebarTitle.textContent = 'Markering ' + id; sidebar.style.display = 'block';
        noteBody.innerHTML = html; noteBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        pasteHint.style.display = IS_PLAYER ? 'none' : 'block';
      }
      (IS_MOBILE ? sheetBody : noteBody).querySelectorAll('img').forEach(img => attachImageClick(img));
      bindOnce();
      (IS_MOBILE ? null : editorBtns).style.display = IS_PLAYER ? 'none' : 'flex';
    };
    if (!store[id]){ idbGet(id).then(html => { store[id] = { html: html || 'Skriv din not här...' }; render(store[id].html); }); }
    else render(store[id].html || 'Skriv din not här...');
  }

  function closePanels(){ sidebar.style.display = 'none'; sheet.style.display = 'none'; if (openId){ const marker = world.querySelector(`.marker[data-id="${openId}"]`); if (marker) marker.classList.remove('open'); } openId = null; }

  stage.addEventListener('click', e => { if (mode !== 'notes') return; if (e.target.classList && e.target.classList.contains('marker')) return; closePanels(); });

  // ===== Bottenskiva: drag upp/ner =====
  const sheetPanel = document.getElementById('sheetPanel');
  const sheetHandle = document.getElementById('sheetHandle');
  sheetClose.addEventListener('click', () => closePanels());

  let sheetState = 'half'; // 'closed' | 'half' | 'full'
  function setSheetHeight(state){
    sheetState = state;
    const vh = (visualViewport ? visualViewport.height : window.innerHeight);
    const half = Math.round(vh * 0.48); const full = Math.round(vh * 0.92);
    const h = state==='full' ? full : (state==='half' ? half : 0);
    sheetBody.style.maxHeight = (state==='full' ? (full - 74) : (half - 74)) + 'px';
    sheetPanel.style.transition = 'transform 180ms ease-out';
    sheetPanel.style.transform = `translateY(${state==='closed' ? (h+40) : 0}px)`;
    if (state==='closed') sheet.style.display = 'none'; else sheet.style.display = 'block';
    setTimeout(()=>{ sheetPanel.style.transition = 'none'; }, 200);
  }
  function openSheet(state='half'){ setSheetHeight(state); }

  // Drag på handtaget
  let dragStartY = 0; let dragStartState = 'half';
  sheetHandle.addEventListener('pointerdown', e => { dragStartY = e.clientY; dragStartState = sheetState; sheetHandle.setPointerCapture(e.pointerId); });
  sheetHandle.addEventListener('pointermove', e => {
    if (!dragStartY) return; const dy = e.clientY - dragStartY; const dir = dy > 0 ? 'down' : 'up';
    const threshold = Math.abs(dy) > 30;
    if (threshold){
      if (dir==='up') setSheetHeight('full'); else setSheetHeight('closed');
      dragStartY = 0;
    }
  });
  sheetHandle.addEventListener('pointerup', ()=> dragStartY=0);

  // ===== MÄTNING =====
  let mode = 'notes'; let measurePoints = []; let measurePath = null;
  function setMode(newMode){ mode = newMode; btnModeNotes.classList.toggle('active', mode==='notes'); btnModeMeasure.classList.toggle('active', mode==='measure'); modeLabel.textContent = 'Läge: ' + (mode==='notes' ? 'Notiser' : 'Mätning'); if (mode==='measure') closePanels(); }
  btnModeNotes.addEventListener('click', () => setMode('notes'));
  btnModeMeasure.addEventListener('click', () => setMode('measure'));
  btnUndo.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints.pop(); updateMeasurePath(); });
  btnReset.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints = []; updateMeasurePath(); });
  function formatMeters(m){ return (m < 1000) ? Math.round(m) + ' m' : (m/1000).toFixed(2) + ' km'; }
  function updateReadout(){ const pxPerKm = 1000 / getMetersPerPixel(); readout.textContent = 'Skala: ' + Math.round(pxPerKm) + ' px/km'; }
  updateReadout();
  function updateMeasurePath(){ if (!measurePoints.length) { if (measurePath) { measurePath.remove(); measurePath=null; } updateReadout(); return; } const d = measurePoints.map((p,i)=> (i? 'L':'M') + p.x + ' ' + p.y).join(' '); if (!measurePath){ measurePath = document.createElementNS('http://www.w3.org/2000/svg','path'); measurePath.setAttribute('class','measure-line'); overlay.appendChild(measurePath); } measurePath.setAttribute('d', d); let totalPx = 0; for (let i=1;i<measurePoints.length;i++){ const a=measurePoints[i-1], b=measurePoints[i]; totalPx += Math.hypot(b.x-a.x, b.y-a.y); } readout.textContent = 'Total: ' + formatMeters(totalPx * getMetersPerPixel()); }
  stage.addEventListener('click', e => { if (mode!=='measure') return; const rect=stage.getBoundingClientRect(); const { wx, wy } = clientToWorldXY(e.clientX, e.clientY); measurePoints.push({x:wx,y:wy}); updateMeasurePath(); });

  // ===== Skallinje =====
  const SCALE_CANDIDATES = [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000];
  function updateScaleBar(){ const targetMin = 80, targetMax = 220; let best = SCALE_CANDIDATES[0]; let bestPx = metersToScreenPx(best); for (const m of SCALE_CANDIDATES){ const px = metersToScreenPx(m); if (px >= targetMin && px <= targetMax){ best = m; bestPx = px; break; } if (Math.abs(px - targetMin) < Math.abs(bestPx - targetMin)){ best = m; bestPx = px; } } sbBar.style.width = Math.max(10, Math.round(bestPx)) + 'px'; sbLabel.textContent = (best < 1000) ? (best + ' m') : ((best/1000) + ' km'); }
  const metersToScreenPx = m => (m / getMetersPerPixel()) * scale;

  // ===== Export =====
  async function exportData(){
    try {
      await openDB();
      const meta = JSON.parse(localStorage.getItem(LSK) || '[]');
      const htmls = await idbBulkGet(meta.map(m => m.id));
      const htmlById = {}; htmls.forEach(({id, html}) => { htmlById[id] = html || ''; });
      const payload = { exportedAt: new Date().toISOString(), metersPerPixel: getMetersPerPixel(), markers: meta.map(m => ({ id: m.id, x: m.x, y: m.y, html: htmlById[m.id] || '' })) };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'data.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
    } catch(err){ console.error(err); alert('Export misslyckades: ' + err.message); }
  }
  btnExport.addEventListener('click', () => { if (IS_PLAYER) return; exportData(); });

  // ===== Init =====
  async function init(){
    imgW = map.naturalWidth; imgH = map.naturalHeight; await openDB();
    if (IS_PLAYER){
      btnExport.style.display = 'none';
      await loadAllFromJSON();
      pasteHint.style.display = 'none'; editorBtns.style.display = 'none'; sheetHint.style.display = 'none';
    } else {
      await loadAllFromLocal();
    }
    fitToScreenAndCenter(); clampPan(); applyTransform(); bindOnce(); updateReadout();
  }
  if (map.complete && map.naturalWidth) init(); else map.onload = init;
  window.addEventListener('resize', () => { clampPan(); applyTransform(); });
})();
</script>
</body>
</html>
