<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>index – Interaktiv karta (mobiloptimerad v2.7)</title>
<style>
  :root { --bg:#0f1115; --ink:#e6e6e6; --muted:#2a3142; --panel:#141822; --shadow: rgba(0,0,0,.45); --accent:#ffd166; --line:#7dd3fc; --vh: 1vh; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow: hidden; }

  /* Stage / world */
  #stage { position: relative; width: 100vw; height: calc(var(--vh) * 100); overflow: hidden; touch-action: none; }
  #world { position: absolute; left: 0; top: 0; transform-origin: 0 0; will-change: transform; }
  #map { display:block; user-select: none; -webkit-user-drag: none; pointer-events: none; max-width: none; }

  /* Markörer */
  .marker { position: absolute; width: 32px; height: 32px; transform: translate(-50%, -100%); cursor: pointer;
            background-image: url('ikonkarta.png'); background-size: contain; background-position:center; background-repeat:no-repeat; }
  .marker.open { background-image: url('ikonkarta2.png'); filter: drop-shadow(0 0 6px var(--accent)); }

  /* Desktop-sidopanel */
  #sidebar { position: fixed; left: 0; top: 0; height: 100dvh; width: 360px; max-width: 90vw; background: rgba(20,24,34,.96);
             border-right: 1px solid var(--muted); box-shadow: 0 6px 20px var(--shadow); z-index: 30; display: none; }
  #sidebar header { display:flex; align-items:center; justify-content: space-between; gap:8px; padding:10px 12px; border-bottom:1px solid #262c3b; }
  #sidebar h3 { margin:0; font-size:16px; font-weight:600; opacity:.9; }
  .mini { border:1px solid var(--muted); background:#1a2030; color:#ddd; padding:6px 10px; border-radius:8px; cursor:pointer; }
  #content { height: calc(100dvh - 52px); overflow:auto; padding:12px; }
  #noteBody { background:#0e1220; border:1px solid #2a3142; border-radius:8px; padding:10px; min-height: 180px; white-space: pre-wrap; outline:none; }
  #noteBody:focus { box-shadow: inset 0 0 0 2px #3b82f6; }
  .note-img { max-width: 100%; height: auto; display:block; margin:8px 0; border-radius:6px; border:1px solid #2a3142; cursor: zoom-in; }

  #stage.grabbing, body.grabbing { cursor: grabbing; }

  /* Lightbox */
  #lightbox { position: fixed; inset: 0; background: rgba(0,0,0,.9); display: none; align-items: center; justify-content: center; z-index: 100; }
  #lightbox img { max-width: 96vw; max-height: 96vh; box-shadow: 0 10px 35px rgba(0,0,0,.6); border-radius: 8px; }

  /* Overlay SVG för mätning */
  #overlay { position:absolute; left:0; top:0; overflow:visible; pointer-events:none; }
  .measure-line { stroke: var(--line); stroke-width: 2; fill: none; vector-effect: non-scaling-stroke; }

  /* Toolbox (sticky) */
  #toolbox { position: fixed; left: 8px; right: 8px; top: env(safe-area-inset-top, 8px); display: flex; gap: 8px; z-index: 60; align-items:center; flex-wrap: wrap; }
  .toolbtn { background:#111827; color:#e5e7eb; border:1px solid #374151; padding:8px 10px; border-radius:10px; cursor:pointer; font-size:14px; }
  .toolbtn.active { outline: 2px solid #60a5fa; }
  .pill { background:#0b1220; border:1px solid #2a3142; padding:6px 10px; border-radius:999px; font-size:14px; }

  /* Skallinje (UI-overlay) */
  #scalebar { position: fixed; left: 14px; bottom: calc(14px + env(safe-area-inset-bottom)); z-index: 70; color:#e5e7eb; font-size: 12px; }
  #scalebar .bar { height: 6px; background: #e5e7eb; border-radius: 3px; box-shadow: 0 1px 0 rgba(0,0,0,.35) inset; }
  #scalebar .label { margin-top: 6px; text-align: center; opacity: .9; }

  /* Player-banner (off) */
  #playerBanner { display:none; }

  /* Mobiljusteringar */
  @media (max-width: 820px) {
    .toolbtn { padding:6px 8px; font-size:12px; }
    .pill { padding:4px 8px; font-size:12px; }
    #sidebar { display:none !important; }
  }

  /* Bottenskiva (mobil-notiser) */
  #sheet { position: fixed; left: 0; right: 0; bottom: 0; z-index: 90; display:none; }
  #sheetPanel { margin: 0 auto; max-width: 880px; background: rgba(20,24,34,.98); border-top-left-radius: 16px; border-top-right-radius: 16px; border:1px solid #2a3142; box-shadow: 0 -8px 24px rgba(0,0,0,.45); padding: 6px 12px 14px; transform: translateY(0); will-change: transform; touch-action: pan-y; }
  #sheetHeader { display:flex; align-items:center; justify-content: space-between; gap:8px; padding-bottom:8px; border-bottom:1px solid #262c3b; }
  #sheetHandle { width: 44px; height: 5px; background:#3b4154; border-radius: 999px; margin: 4px auto 10px; opacity:.85; touch-action:none; }
  #sheetBody { max-height: 48dvh; overflow:auto; -webkit-overflow-scrolling: touch; }
  .mini-ghost { background:transparent; border:1px solid #374151; color:#e5e7eb; padding:6px 10px; border-radius:10px; cursor:pointer; }
</style>
</head>
<body>
  <aside id="sidebar">
    <header>
      <h3 id="sidebarTitle">Markering</h3>
      <div id="editorBtns">
        <button id="addImg" class="mini" type="button" title="Lägg till bild">+ Bild</button>
        <input id="imgInput" type="file" accept="image/*" style="display:none" />
      </div>
    </header>
    <div id="content">
      <div id="noteBody" contenteditable="true" spellcheck="false">Skriv din not här...</div>
      <p id="pasteHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: Klistra in (Ctrl/Cmd+V) eller dra‑och‑släpp en bild direkt i textfältet. Klicka på en bild för stor visning.</p>
    </div>
  </aside>

  <!-- Mobil-bottenskiva -->
  <div id="sheet">
    <div id="sheetPanel">
      <div id="sheetHandle"></div>
      <div id="sheetHeader">
        <h3 id="sheetTitle" style="margin:0;font-size:15px">Markering</h3>
        <div id="sheetBtns">
          <button id="mAddImg" class="mini-ghost" type="button" title="Lägg till bild">+ Bild</button>
          <button id="sheetClose" class="mini-ghost" type="button" title="Stäng">Stäng</button>
          <input id="mImgInput" type="file" accept="image/*" style="display:none" />
        </div>
      </div>
      <div id="sheetBody" contenteditable="true" spellcheck="false"></div>
      <p id="sheetHint" style="opacity:.75; font-size:12px; margin-top:8px">Tips: dra handtaget för att expandera/stänga.</p>
    </div>
  </div>

  <div id="toolbox">
    <span class="pill" id="modeLabel">Läge: Notiser</span>
    <button id="btnModeNotes" class="toolbtn active" title="Skapa/hantera notiser">Notiser</button>
    <button id="btnModeMeasure" class="toolbtn" title="Mät avstånd">Mät</button>
    <button id="btnUndo" class="toolbtn" title="Ångra senaste mätpunkt">Ångra</button>
    <button id="btnReset" class="toolbtn" title="Ny mätning">Ny mätning</button>
    <button id="btnExport" class="toolbtn" title="Exportera data.json (inbäddade bilder)">Export</button>
    <span id="readout" class="pill">Skala: okänd</span>
  </div>

  <div id="playerBanner">Player‑läge (read‑only) – läser data.json</div>

  <div id="scalebar">
    <div class="bar" id="sbBar" style="width:120px"></div>
    <div class="label" id="sbLabel">—</div>
  </div>

  <div id="stage">
    <div id="world">
      <img id="map" src="Tyraal.webp" alt="Tyraal-karta" />
      <svg id="overlay"></svg>
    </div>
  </div>

  <div id="lightbox"><img id="lightboxImg" alt="" /></div>

<script>
(function(){
  // ===== Stabil 100vh på mobiler =====
  const setVH = () => document.documentElement.style.setProperty('--vh', (visualViewport ? visualViewport.height : window.innerHeight) * 0.01 + 'px');
  setVH(); if (window.visualViewport){ visualViewport.addEventListener('resize', setVH); } else { window.addEventListener('resize', setVH); }

  const IS_PLAYER = (location.hash === '#player') || (new URLSearchParams(location.search).get('mode') === 'player');
  const IS_MOBILE = matchMedia('(max-width: 820px)').matches;

  // ===== SKALA =====
  const METERS_PER_PIXEL = 250000 / 1073.6; // ≈ 232.77 m/px
  const MAP_WIDTH = 8192, MAP_HEIGHT = 5462; // fallback
  let metersPerPixelOverride = NaN; 
  const getMetersPerPixel = () => (isNaN(metersPerPixelOverride) ? METERS_PER_PIXEL : metersPerPixelOverride);

  // ===== DOM =====
  const stage = document.getElementById('stage');
  const world = document.getElementById('world');
  const map = document.getElementById('map');
  const overlay = document.getElementById('overlay');
  const sidebar = document.getElementById('sidebar');
  const sidebarTitle = document.getElementById('sidebarTitle');
  const editorBtns = document.getElementById('editorBtns');
  const noteBody = document.getElementById('noteBody');
  const pasteHint = document.getElementById('pasteHint');
  const addImgBtn = document.getElementById('addImg');
  const imgInput = document.getElementById('imgInput');
  const mAddImgBtn = document.getElementById('mAddImg');
  const mImgInput = document.getElementById('mImgInput');
  const sheet = document.getElementById('sheet');
  const sheetPanel = document.getElementById('sheetPanel');
  const sheetBody = document.getElementById('sheetBody');
  const sheetTitle = document.getElementById('sheetTitle');
  const sheetClose = document.getElementById('sheetClose');
  const sheetHint = document.getElementById('sheetHint');
  const sheetHandle = document.getElementById('sheetHandle');
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');
  const modeLabel = document.getElementById('modeLabel');
  const btnModeNotes = document.getElementById('btnModeNotes');
  const btnModeMeasure = document.getElementById('btnModeMeasure');
  const btnUndo = document.getElementById('btnUndo');
  const btnReset = document.getElementById('btnReset');
  const btnExport = document.getElementById('btnExport');
  const readout = document.getElementById('readout');
  const sbBar = document.getElementById('sbBar');
  const sbLabel = document.getElementById('sbLabel');

  // ===== Kamera =====
  let scale = 1, MIN = 1, MAX = 24, startScale = 1; 
  let tx = 0, ty = 0, imgW = 0, imgH = 0;

  function getPanBounds(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w = imgW * scale, h = imgH * scale;
    const centerX = (vw - w) / 2, centerY = (vh - h) / 2;
    if (w <= vw && h <= vh) return { minTx:centerX, maxTx:centerX, minTy:centerY, maxTy:centerY };
    if (w <= vw) return { minTx:centerX, maxTx:centerX, minTy: Math.min(0, vh - h), maxTy: 0 };
    if (h <= vh) return { minTx: Math.min(0, vw - w), maxTx: 0, minTy:centerY, maxTy:centerY };
    return { minTx: Math.min(0, vw - w), maxTx: 0, minTy: Math.min(0, vh - h), maxTy: 0 };
  }
  const clamp = (v,a,b) => Math.min(b, Math.max(a,v));
  function clampPan(){ const b = getPanBounds(); tx = clamp(tx, b.minTx, b.maxTx); ty = clamp(ty, b.minTy, b.maxTy); }

  function applyTransform(){
    world.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    world.querySelectorAll('.marker').forEach(el => { el.style.transform = `translate(-50%, -100%) scale(${1/scale})`; });
    overlay.setAttribute('width', imgW); overlay.setAttribute('height', imgH);
    updateScaleBar();
  }

  function zoomAt(screenX, screenY, factor){
    const rect = stage.getBoundingClientRect();
    const x = screenX - rect.left; const y = screenY - rect.top;
    const wx = (x - tx) / scale; const wy = (y - ty) / scale;
    const ns = clamp(scale * factor, MIN, MAX);
    tx = x - wx * ns; ty = y - wy * ns; scale = ns; clampPan(); applyTransform();
  }

  function fitToScreenAndCenter(){
    const vw = stage.clientWidth, vh = stage.clientHeight;
    const w0 = map.naturalWidth || MAP_WIDTH; const h0 = map.naturalHeight || MAP_HEIGHT;
    imgW = w0; imgH = h0;
    const s = Math.min(vw / imgW, vh / imgH);
    startScale = s; scale = s; 
    MIN = startScale * 0.98;  
    const w = imgW * scale, h = imgH * scale;
    tx = (vw - w)/2; ty = (vh - h)/2; applyTransform();
  }

  // — Mus-hjul zoom
  stage.addEventListener('wheel', e => { e.preventDefault(); const f = e.deltaY < 0 ? 1.15 : 1/1.15; zoomAt(e.clientX, e.clientY, f); }, {passive:false});

  // — Pointers (touch + mus)
  const pointers = new Map(); // id -> {x,y}
  let lastDist = null;
  let leftPan = false; // vänster-pan på tom yta
  let rightPan = false; // höger-pan var som helst
  let panStart = null;  // {x,y,tx,ty}

  stage.addEventListener('pointerdown', e => {
    const onMarker = !!e.target.closest('.marker');
    // Höger mus → pan alltid
    if (e.pointerType === 'mouse' && e.button === 2){
      rightPan = true; panStart = { x: e.clientX, y: e.clientY, tx, ty };
      window.addEventListener('contextmenu', ev => ev.preventDefault(), { once:true });
      stage.setPointerCapture(e.pointerId);
    }
    // Vänster mus → starta pan endast om inte på markör
    if (e.pointerType === 'mouse' && e.button === 0 && !onMarker){
      leftPan = true; panStart = { x: e.clientX, y: e.clientY, tx, ty };
      stage.setPointerCapture(e.pointerId);
    }

    // Touch: spåra panning/zoom
    if (e.pointerType !== 'mouse'){
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      stage.setPointerCapture(e.pointerId);
    }
  });

  stage.addEventListener('pointermove', e => {
    if (e.pointerType !== 'mouse' && pointers.has(e.pointerId)){
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      const pts = [...pointers.values()];
      if (pts.length === 1 && !leftPan && !rightPan){
        const p = pts[0];
        if (!panStart) panStart = { x: e.clientX, y: e.clientY, tx, ty };
        tx = panStart.tx + (p.x - panStart.x);
        ty = panStart.ty + (p.y - panStart.y);
        clampPan(); applyTransform();
        return;
      }
      if (pts.length === 2){
        const [a,b] = pts; const midX=(a.x+b.x)/2, midY=(a.y+b.y)/2; const dist = Math.hypot(b.x-a.x, b.y-a.y);
        if (lastDist==null) { lastDist = dist; return; }
        const factor = dist / lastDist; lastDist = dist; zoomAt(midX, midY, factor);
        return;
      }
    }

    // Mus-pan
    if ((leftPan || rightPan) && panStart){
      const p = { x: e.clientX, y: e.clientY };
      tx = panStart.tx + (p.x - panStart.x);
      ty = panStart.ty + (p.y - panStart.y);
      clampPan(); applyTransform();
    }
  });

  function endPointer(e){
    if (e.pointerType !== 'mouse'){
      pointers.delete(e.pointerId);
      if (pointers.size < 2) lastDist = null;
      if (pointers.size === 0) panStart = null;
    }
    if (e.pointerType === 'mouse'){
      if (leftPan || rightPan) stage.releasePointerCapture?.(e.pointerId);
      leftPan = false; rightPan = false; panStart = null;
    }
  }
  stage.addEventListener('pointerup', endPointer);
  stage.addEventListener('pointercancel', endPointer);

  // ===== Lagring (IndexedDB + localStorage) =====
  const LSK = 'tyraal_markers_meta_v20';
  const DB_NAME = 'tyraal_db'; const DB_STORE = 'notes';
  let db = null;
  function openDB(){ return new Promise((resolve, reject) => { const req = indexedDB.open(DB_NAME, 1); req.onupgradeneeded = () => { db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE, { keyPath: 'id' }); }; req.onsuccess = () => { db = req.result; resolve(db); }; req.onerror = () => reject(req.error); }); }
  function idbGet(id){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readonly'); const st = tx.objectStore(DB_STORE); const r = st.get(id); r.onsuccess = () => resolve(r.result?.html || ''); r.onerror = () => reject(r.error); }); }
  function idbSet(id, html){ return new Promise((resolve, reject) => { const tx = db.transaction(DB_STORE, 'readwrite'); const st = tx.objectStore(DB_STORE); const r = st.put({ id, html }); r.onsuccess = () => resolve(); r.onerror = () => reject(r.error); }); }
  function idbBulkGet(ids){ return Promise.all(ids.map(id => idbGet(id).then(html => ({ id, html })))); }
  function saveMeta(){ if (IS_PLAYER) return; const out = [...world.querySelectorAll('.marker')].map(m => ({ id: m.dataset.id, x: parseFloat(m.style.left), y: parseFloat(m.style.top) })); try { localStorage.setItem(LSK, JSON.stringify(out)); } catch(e){} }
  async function saveHTML(id, html){ if (IS_PLAYER) return; try { await idbSet(id, html); } catch(e){} }
  async function loadAllFromLocal(){ const meta = JSON.parse(localStorage.getItem(LSK) || '[]'); meta.forEach(o => createMarker(o.x, o.y, o.id, false)); const htmls = await idbBulkGet(meta.map(m => m.id)); htmls.forEach(({id, html}) => { store[id] = { html: html || '' }; }); }

  // ===== Player: data.json =====
  async function loadAllFromJSON(){
    try {
      const res = await fetch('data.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Kunde inte läsa data.json');
      const data = await res.json();
      if (typeof data.metersPerPixel === 'number' && isFinite(data.metersPerPixel)) metersPerPixelOverride = data.metersPerPixel;
      if (Array.isArray(data.markers)){
        data.markers.forEach(m => { createMarker(m.x, m.y, m.id, false); store[m.id] = { html: m.html || '' }; });
      }
    } catch (err){ console.error(err); alert('Kunde inte ladda spelardata (data.json).'); }
  }

  // ===== Per‑markör cache =====
  const store = {}; let openId = null;

  // ===== Bildinmatning (inbäddade data-URLer) =====
  let inserting = false, handlersBound = false;
  function fileToDataURL(file){ return new Promise((resolve, reject) => { const r=new FileReader(); r.onload=()=>resolve(r.result); r.onerror=reject; r.readAsDataURL(file); }); }
  async function insertImagesFromFiles(targetEl, files){
    if (inserting) return; inserting = true;
    try {
      for (const f of files){ if (!f || !f.type || !f.type.startsWith('image/')) continue; const data = await fileToDataURL(f); const img = document.createElement('img'); img.className = 'note-img'; img.src = data; attachImageClick(img); targetEl.appendChild(img); }
      if (openId){ const html = (IS_MOBILE ? sheetBody.innerHTML : noteBody.innerHTML); store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }
    } finally { inserting = false; }
  }
  function attachImageClick(img){ img.addEventListener('click', e => { e.stopPropagation(); openLightbox(img.src); }); }

  function bindOnce(){ if (handlersBound) return; handlersBound = true; if (!IS_PLAYER){
      addImgBtn?.addEventListener('click', () => { imgInput.value=''; imgInput.click(); });
      imgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(noteBody, files); imgInput.value=''; });
      mAddImgBtn?.addEventListener('click', () => { mImgInput.value=''; mImgInput.click(); });
      mImgInput?.addEventListener('change', async e => { const files=e.target.files; if (files?.length) await insertImagesFromFiles(sheetBody, files); mImgInput.value=''; });
      const pasteHandler = async (e, target) => { const items = e.clipboardData?.items || []; const files = []; for (const it of items){ if (it.kind==='file' && it.type.startsWith('image/')) files.push(it.getAsFile()); } if (files.length){ e.preventDefault(); e.stopPropagation(); if (!inserting) await insertImagesFromFiles(target, files); } };
      noteBody?.addEventListener('paste', e => pasteHandler(e, noteBody));
      sheetBody?.addEventListener('paste', e => pasteHandler(e, sheetBody));
      const inputHandler = async (target) => { if(openId){ const html = target.innerHTML; store[openId] = { html }; await saveHTML(openId, html); saveMeta(); }}
      noteBody?.addEventListener('input', () => inputHandler(noteBody));
      sheetBody?.addEventListener('input', () => inputHandler(sheetBody));
    }
  }

  // ===== Lightbox =====
  function openLightbox(src){ lightboxImg.src = src; lightbox.style.display = 'flex'; }
  function closeLightbox(){ lightbox.style.display = 'none'; lightboxImg.src = ''; }
  lightbox.addEventListener('click', closeLightbox);

  // ===== Markörer (PC): klick öppnar, Alt/Shift + drag flyttar, drag-tröskel
  function uid(){ return Math.random().toString(36).slice(2,9); }
  function clientToWorldXY(x,y){ const rect = stage.getBoundingClientRect(); const cx = x - rect.left; const cy = y - rect.top; return { wx: (cx - tx) / scale, wy: (cy - ty) / scale }; }

  // Skapa ny markör (dblclick på tom karta)
  stage.addEventListener('dblclick', e => {
    if (mode !== 'notes' || IS_PLAYER) return;
    if (e.target.closest('.marker') || e.target.closest('#sidebar') || e.target.closest('#sheet')) return;
    e.preventDefault();
    const { wx, wy } = clientToWorldXY(e.clientX, e.clientY);
    const id = uid(); store[id] = { html: 'Skriv din not här...' };
    createMarker(wx, wy, id, true); openMarker(id);
  }, { passive:false });

  function createMarker(wx, wy, id, saveNow=true){
    if (!isFinite(wx) || !isFinite(wy)) return null;
    const m = document.createElement('div'); m.className = 'marker'; m.dataset.id = id; m.style.left = wx + 'px'; m.style.top = wy + 'px';

    let dragging = false, canDrag = false, startX=0, startY=0;
    const DRAG_THRESHOLD = 5; // px
    let suppressNextClick = false;

    // Öppna vid klick (om ingen drag)
    m.addEventListener('click', ev => {
      if (suppressNextClick) { suppressNextClick = false; return; }
      ev.stopPropagation();
      if (openId === id) closePanels(); else openMarker(id);
    });

    // Alt/Shift + drag för flytt
    m.addEventListener('pointerdown', ev => {
      if (mode !== 'notes' || IS_PLAYER) return;
      if (ev.pointerType==='mouse' && ev.button!==0) return; // bara vänster
      canDrag = ev.altKey || ev.shiftKey; dragging = false;
      startX = ev.clientX; startY = ev.clientY;
      if (canDrag){ document.body.classList.add('grabbing'); stage.classList.add('grabbing'); m.setPointerCapture(ev.pointerId); }
      ev.stopPropagation();
    });
    m.addEventListener('pointermove', ev => {
      if (!canDrag) return;
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      if (!dragging && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) dragging = true;
      if (dragging){
        const { wx, wy } = clientToWorldXY(ev.clientX, ev.clientY);
        m.style.left = wx + 'px';
        m.style.top  = wy + 'px';
      }
    });
    m.addEventListener('pointerup', ev => {
      if (dragging){ suppressNextClick = true; saveMeta(); }
      dragging = false; canDrag = false;
      document.body.classList.remove('grabbing'); stage.classList.remove('grabbing');
    });

    m.addEventListener('contextmenu', async ev => { if (IS_PLAYER) return; ev.preventDefault(); if (confirm('Ta bort denna markering och dess notis?')) { if (openId === id) closePanels(); world.removeChild(m); delete store[id]; saveMeta(); try { await idbSet(id, ''); } catch(_){} } });

    world.appendChild(m);
    if (saveNow) saveMeta();
    return m;
  }

  function openMarker(id){
    if (openId && openId !== id){ const prev = world.querySelector(`.marker[data-id="${openId}"]`); if (prev) prev.classList.remove('open'); }
    openId = id; const marker = world.querySelector(`.marker[data-id="${id}"]`); if (marker) marker.classList.add('open');
    const html = store[id]?.html;
    const render = (h) => {
      if (IS_MOBILE){
        sheetTitle.textContent = 'Markering ' + id; sheet.style.display = 'block';
        sheetBody.innerHTML = h; sheetBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        sheetHint.style.display = IS_PLAYER ? 'none' : 'block';
        openSheet('half');
      } else {
        sidebarTitle.textContent = 'Markering ' + id; sidebar.style.display = 'block';
        noteBody.innerHTML = h; noteBody.contentEditable = IS_PLAYER ? 'false' : 'true';
        pasteHint.style.display = IS_PLAYER ? 'none' : 'block';
      }
      (IS_MOBILE ? sheetBody : noteBody).querySelectorAll('img').forEach(img => attachImageClick(img));
      bindOnce();
      (IS_MOBILE ? null : editorBtns).style.display = IS_PLAYER ? 'none' : 'flex';
    };
    if (typeof html !== 'string'){ idbGet(id).then(h => { store[id] = { html: h || 'Skriv din not här...' }; render(store[id].html); }); }
    else render(html || 'Skriv din not här...');
  }

  function closePanels(){
    sidebar.style.display = 'none';
    sheet.style.display = 'none';
    const prev = openId ? world.querySelector(`.marker[data-id="${openId}"]`) : null;
    if (prev) prev.classList.remove('open');
    openId = null;
  }

  // Klick på tom karta stänger panel
  stage.addEventListener('click', e => {
    if (mode !== 'notes') return;
    if (e.target.closest('.marker')) return; // låt marker‑klick sköta sig
    closePanels();
  });

  // ===== Bottenskiva: swipe upp/ner =====
  let sheetState = 'half'; // 'closed' | 'half' | 'full'
  let sheetOffsetY = 0; // nuvarande translateY i px (positiv = nedåt)

  function sizes(){
    const vh = (visualViewport ? visualViewport.height : window.innerHeight);
    return {
      half: Math.round(vh * 0.50),    // lite större "half" för mer innehåll
      full: Math.round(vh * 0.965),   // nästan fullskärm
      header: 74
    };
  }

  function applySheetTransform(offset){
    sheetOffsetY = offset;
    sheetPanel.style.transform = `translateY(${Math.max(0, offset)}px)`;
  }

  function setSheetHeight(state, animate=true){
    sheetState = state;
    const S = sizes();
    const h = state==='full' ? S.full : (state==='half' ? S.half : 0);
    sheetBody.style.maxHeight = (state==='full' ? (S.full - S.header) : (S.half - S.header)) + 'px';
    if (animate) sheetPanel.style.transition = 'transform 160ms ease-out';
    applySheetTransform(state==='closed' ? (h+40) : 0);
    if (state==='closed') {
      closePanels();
    } else {
      sheet.style.display = 'block';
    }
    if (animate) setTimeout(()=>{ sheetPanel.style.transition = 'none'; }, 180);
  }
  function openSheet(state='half'){ sheet.style.display = 'block'; setSheetHeight(state); }

  // Swipe-gest: starta på handtag/header, eller från body när scrollTop==0 (för nedåt-stäng)
  let dragStartY = 0, dragStartTime = 0, draggingSheet = false, startState = 'half', baseOffset = 0, lastY = 0;
  const SWIPE_THRESHOLD_FRACTION = 0.12; // var mer känslig (tidigare ~0.18)
  const FAST_VELOCITY = 0.45; // px/ms – mer lätt att trigga

  function canStartDragFromBody(){ return sheetBody.scrollTop <= 0; }

  function sheetDragStart(e){
    draggingSheet = true; dragStartY = e.clientY; lastY = e.clientY; dragStartTime = performance.now(); startState = sheetState;
    baseOffset = sheetOffsetY; // vanligtvis 0 när öppen
    sheetPanel.setPointerCapture(e.pointerId);
  }
  function sheetDragMove(e){
    if (!draggingSheet) return;
    const dy = e.clientY - dragStartY;
    const S = sizes();
    // När vi drar uppåt vill vi tillåta en liten "stretch" uppåt (negativ offset), clampad
    const upAllowance = -40;
    // När vi drar nedåt låter vi följa fingret
    const newOffset = clamp(baseOffset + dy, upAllowance, S.full);
    sheetPanel.style.transition = 'none';
    applySheetTransform(newOffset);
    lastY = e.clientY;
  }
  function sheetDragEnd(e){
    if (!draggingSheet) return;
    draggingSheet = false; sheetPanel.releasePointerCapture?.(e.pointerId);
    const dy = e.clientY - dragStartY; const dt = Math.max(1, performance.now() - dragStartTime);
    const vy = dy / dt; // px/ms
    const S = sizes();
    const threshold = S.full * SWIPE_THRESHOLD_FRACTION;

    // Snabbt beslut
    if (dy > threshold || vy > FAST_VELOCITY) { // nedåt → stäng
      setSheetHeight('closed');
      return;
    }
    if (-dy > threshold || -vy > FAST_VELOCITY) { // uppåt → full
      setSheetHeight('full');
      return;
    }
    // Annars: gå till närmaste (half som default)
    setSheetHeight(startState === 'full' ? 'half' : 'half');
  }

  // Bind drag på handtag och header
  ;[sheetHandle, document.getElementById('sheetHeader')].forEach(el => {
    el.addEventListener('pointerdown', e => { e.preventDefault(); sheetDragStart(e); });
    el.addEventListener('pointermove', sheetDragMove);
    el.addEventListener('pointerup', sheetDragEnd);
    el.addEventListener('pointercancel', sheetDragEnd);
  });

  // Tillåt drag från body när man drar NER och är i topp (för att stänga)
  sheetBody.addEventListener('pointerdown', e => { if (canStartDragFromBody()) sheetDragStart(e); });
  sheetBody.addEventListener('pointermove', e => {
    if (!draggingSheet) return;
    const goingDown = (e.clientY - lastY) > 0;
    // Förhindra att webbläsaren "pull-to-refresh" eller likn. kickar in
    e.preventDefault();
    if (goingDown) sheetDragMove(e);
  }, { passive:false });
  sheetBody.addEventListener('pointerup', sheetDragEnd);
  sheetBody.addEventListener('pointercancel', sheetDragEnd);

  // Stäng-knapp stänger notis helt
  sheetClose.addEventListener('click', () => setSheetHeight('closed'));

  // ==== Viktigt: INGEN zoom inuti notisen ====
  // Stoppa pinch/dubbel-tap zoom och hjul-zoom inne i panelen på mobiler och desktop
  ['pointerdown','pointermove','wheel','dblclick'].forEach(evt => {
    sheetPanel.addEventListener(evt, e => {
      if (evt === 'pointermove' && e.pointerType !== 'mouse'){
        // Om fler än 1 touch pekare är aktiva över panelen → blockera (förhindra att scenen zoomar)
        // Vi kan inte läsa globalt antal här, men att bara preventDefault på touchmove över panelen räcker.
        e.preventDefault();
      }
      if (evt === 'wheel') e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
  });
  // iOS Safari special: förhindra pinch-zoom-gest i panelen
  ['gesturestart','gesturechange','gestureend'].forEach(evt => {
    sheetPanel.addEventListener(evt, e => e.preventDefault());
  });

  // ===== MÄTNING =====
  let mode = 'notes'; let measurePoints = []; let measurePath = null;
  function setMode(newMode){ mode = newMode; btnModeNotes.classList.toggle('active', mode==='notes'); btnModeMeasure.classList.toggle('active', mode==='measure'); modeLabel.textContent = 'Läge: ' + (mode==='notes' ? 'Notiser' : 'Mätning'); if (mode==='measure') closePanels(); }
  btnModeNotes.addEventListener('click', () => setMode('notes'));
  btnModeMeasure.addEventListener('click', () => setMode('measure'));
  btnUndo.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints.pop(); updateMeasurePath(); });
  btnReset.addEventListener('click', () => { if (mode !== 'measure') setMode('measure'); measurePoints = []; updateMeasurePath(); });
  const formatMeters = m => (m < 1000) ? Math.round(m) + ' m' : (m/1000).toFixed(2) + ' km';
  function updateReadout(){ const pxPerKm = 1000 / getMetersPerPixel(); readout.textContent = 'Skala: ' + Math.round(pxPerKm) + ' px/km'; }
  updateReadout();
  function updateMeasurePath(){ if (!measurePoints.length) { if (measurePath) { measurePath.remove(); measurePath=null; } updateReadout(); return; } const d = measurePoints.map((p,i)=> (i? 'L':'M') + p.x + ' ' + p.y).join(' '); if (!measurePath){ measurePath = document.createElementNS('http://www.w3.org/2000/svg','path'); measurePath.setAttribute('class','measure-line'); overlay.appendChild(measurePath); } measurePath.setAttribute('d', d); let totalPx = 0; for (let i=1;i<measurePoints.length;i++){ const a=measurePoints[i-1], b=measurePoints[i]; totalPx += Math.hypot(b.x-a.x, b.y-a.y); } readout.textContent = 'Total: ' + formatMeters(totalPx * getMetersPerPixel()); }
  stage.addEventListener('click', e => { if (mode!=='measure') return; const rect=stage.getBoundingClientRect(); const wx = (e.clientX - rect.left - tx) / scale; const wy = (e.clientY - rect.top - ty) / scale; measurePoints.push({x:wx,y:wy}); updateMeasurePath(); });

  // ===== Skallinje =====
  const SCALE_CANDIDATES = [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000];
  function updateScaleBar(){ const targetMin = 80, targetMax = 220; let best = SCALE_CANDIDATES[0]; let bestPx = metersToScreenPx(best); for (const m of SCALE_CANDIDATES){ const px = metersToScreenPx(m); if (px >= targetMin && px <= targetMax){ best = m; bestPx = px; break; } if (Math.abs(px - targetMin) < Math.abs(bestPx - targetMin)){ best = m; bestPx = px; } } sbBar.style.width = Math.max(10, Math.round(bestPx)) + 'px'; sbLabel.textContent = (best < 1000) ? (best + ' m') : ((best/1000) + ' km'); }
  const metersToScreenPx = m => (m / getMetersPerPixel()) * scale;

  // ===== Export =====
  async function exportData(){
    try {
      await openDB();
      const meta = JSON.parse(localStorage.getItem(LSK) || '[]');
      const htmls = await idbBulkGet(meta.map(m => m.id));
      const htmlById = {}; htmls.forEach(({id, html}) => { htmlById[id] = html || ''; });
      const payload = { exportedAt: new Date().toISOString(), metersPerPixel: getMetersPerPixel(), markers: meta.map(m => ({ id: m.id, x: m.x, y: m.y, html: htmlById[m.id] || '' })) };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'data.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
    } catch(err){ console.error(err); alert('Export misslyckades: ' + err.message); }
  }
  btnExport.addEventListener('click', () => { if (IS_PLAYER) return; exportData(); });

  // ===== Init =====
  async function init(){
    imgW = map.naturalWidth; imgH = map.naturalHeight; await openDB();
    if (IS_PLAYER){
      btnExport.style.display = 'none';
      await loadAllFromJSON();
      pasteHint.style.display = 'none'; editorBtns.style.display = 'none'; sheetHint.style.display = 'none';
    } else {
      await loadAllFromLocal();
    }
    fitToScreenAndCenter(); clampPan(); applyTransform(); bindOnce(); updateReadout();
  }
  if (map.complete && map.naturalWidth) init(); else map.onload = init;
  window.addEventListener('resize', () => { clampPan(); applyTransform(); });
})();
</script>
</body>
</html>
